# 第2章: 署名とセキュリティ検証

この章では、JWTの最も重要な要素である「署名（Signature）」の仕組みと、なぜ改ざんが不可能なのかについて、実験を通して解説します。

## 1. 署名 (Signature) の役割

署名は、トークンが**「信頼できる発行者（Microsoft Entra ID）によって作られたものであり、かつ、途中で書き換えられていないこと」**を証明するためのデータです。

### 仕組み（検印のイメージ）
*   **ヘッダー・ペイロード**: 書類の「本文」。
*   **署名**: 書類に押された**「実印（ハンコ）」**。

APIサーバーは、トークンを受け取ると以下の確認作業（署名検証）を行います。
1.  **ハンコを見る**: 署名データを確認。
2.  **印鑑証明と照合する**: Microsoftの「公開鍵」を使って、ハンコが本物か計算する。
3.  **割り印を確認する**: このハンコが「この本文（ヘッダー・ペイロード）」に対して押されたものかを確認する。

## 2. 署名の作成アルゴリズム (RS256)

署名は以下の計算式で作られます。

$$
\text{署名} = \text{暗号化} \left( \text{ハッシュ} ( \underbrace{\text{ヘッダー} + "." + \text{ペイロード}}_{\text{計算の材料}} ) , \text{秘密鍵} \right)
$$

1.  **ハッシュ化 (SHA-256)**: ヘッダーとペイロードを混ぜて、256ビットの「指紋」データを作ります。
2.  **暗号化 (RSA)**: その指紋を、Microsoftしか持っていない**「秘密鍵」**で暗号化します。

### なぜ改ざんできないのか？
ペイロードと署名は「運命共同体」です。

*   もし攻撃者がペイロードを「一般ユーザー」から「管理者」に書き換えたとします。
*   すると、計算の材料が変わるため、**正しい署名の値も変わってしまいます**。
*   攻撃者は新しい署名を作ろうとしますが、**「秘密鍵」を持っていないため、正しい署名を作れません**。
*   サーバー側で検証すると、「ペイロードと署名が一致しない」というエラーになり、改ざんがバレます。

## 3. セキュリティ上の重要事項

### 通信経路の安全性
*   **HTTPS (SSL/TLS)** を使用している限り、通信経路（トンネルの中）でトークンを盗み見られることはありません。
*   「露出するとまずい」のは、トンネルの入り口（PC）や出口（サーバーログ）での管理ミスです。

### なぜヘッダーとペイロードを送るのか？
*   サーバーは**ステートレス（何も覚えていない）**だからです。
*   「私は田中です（ペイロード）」という情報と、「これが証明書です（署名）」という証拠をセットで渡すことで、サーバーはデータベースを見に行かずにその場で本人確認ができます。

## 4. 実践ツール: `verify_signature.py`

署名の作成と検証、そして「改ざん検知」を体験できるPythonスクリプトです。
あなたがホスト（発行者）になりきって、鍵の生成から署名作成、検証までを行います。

### 必要な準備
このスクリプトは暗号化ライブラリ `cryptography` を使用します。
```bash
uv add cryptography
```

### 使い方
```bash
uv run verify_signature.py
```

### スクリプトの動作内容
1.  **鍵の生成**: RSAの秘密鍵と公開鍵を作ります。
2.  **トークン作成**: `admin: false` のペイロードで正しい署名を作ります。
3.  **検証**: 公開鍵で検証し、成功することを確認します。
4.  **改ざん実験**: ペイロードを `admin: true` に書き換えますが、署名は元のままにします。
5.  **改ざん検知**: 検証が失敗し、改ざんが見抜かれることを確認します。
